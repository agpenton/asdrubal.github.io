---
title: "AWS Lambda for image rendering"
date: 2022-07-15T13:43:31+02:00
draft: false
---

[//]: # (# AWS Lambda for image rendering)


## images-s3-cdn
(terraform/modules/lambda-image-rendering/images-s3-cdn)

There are 3 main buckets involved in our rendering and resizing operations
We use these DNS entries to serve images directly (through a Cloudfront distribution) from S3.

* rndr.juniqe.com
* rndr.juniqe-staging.juniqe.com
* rndr.juniqe-integration.juniqe.com



### juniqe-design-cloud

This bucket is in the main account

We store all high-res printing images in this bucket. Images are organized in verticals and by designer like
* juniqe-design-cloud/Wall Art/06 - Chase Kunz/6-1-101L-40x60.jpg
* juniqe-design-cloud/Wall Art/06 - Chase Kunz/6-1-101L-20x30.jpg
* juniqe-design-cloud/Living/Bed Linen/11 - Leah Flores/11-3-JB01-140x200.jpg
* ....


### juniqe-shop-cloud bucket

This bucket is in the main account

During upload into the designcloud where we generate all possible smaller sized for an uploaded image like  6-1-101L-40x60.jpg
we upload a lower-res image (72 Ã— 72 ppi) into the juniqe-shop-cloud of the largest possible size.

We store images in the juniqe-shop-cloud in the identical bucket/prefix structure as in the juniqe-design-cloud.

The juniqe-shop-cloud will most likely become obsolete once we move to an on-demand rendering approach of both shop images and printing images)

* juniqe-shop-cloud/Wall Art/06 - Chase Kunz/6-1-101L-40x60.jpg (only the largest possible size)
* ....

### juniqe-shop-images

This is the main shop-image bucket that is configured for static content hosting and referenced by **https://rndr.juniqe.com/media/..**
Images that we upload through our cms-app to render on arbitrary cms-block and the like are stored in this bucket as well as
all product images.

For staging and integration we are using

* juniqe-staging-shop-images
* juniqe-integration-shop-images

The folder structure follows the magento legacy folder structure.

* juniqe-shop-images/media/catalog/product/xxx
* juniqe-shop-images/media/catalog/category/xxx
* ....

We are rsyncing from production (**juniqe-shop-images**) to staging and to integration the images that are **not** generated by the lambda functions.


## AWS lambda code
(terraform/modules/juniqe/lambda-image-rendering/lambda,
terraform/modules/juniqe/lambda-image-rendering/product-image-rendering,
terraform/modules/juniqe/lambda-image-rendering/product-image-resize,
terraform/modules/juniqe/lambda-image-rendering/template-cache-cleanup,
terraform/modules/juniqe/lambda-image-rendering/template-image-rendering,
terraform/modules/juniqe/lambda-image-rendering/template-rendering-assembly)

We currently maintain our AWS lambda codebase in 2 repositories.

* git@bitbucket.org:juniqe/lambda-template-rendering.git (scala)
* git@bitbucket.org:juniqe/lambda-image-resize.git (python)


Our view in room rendering is implemented in Scala because we execute some SKU parsing in the templated rendering.  
https://rndr.juniqe.com/template/view_in_room20/x386/c547dacb974435434a9a53a85d2f2ca58cdf1991bbb821e4d3046acad2e42b75/sku_221-121-101P-80x120/view_in_room.jpg


The cache resize and seo optimized cache resize lambda functions are implemented in python because they are very simple and just not a lot of domain specific code.  
https://rndr.juniqe.com/media/catalog/product/cache/x800/221/121/221-121-101P.jpg
https://rndr.juniqe.com/media/catalog/product/seo-cache/x386/675/51/675-51-101P/Frida-treechild-Premium-Poster.jpg


## api-gateway
(terraform/modules/juniqe/lambda-image-rendering/api-gateway)

With API Gateway we implemented all path mappings. We use the DNS entries

* rndr-api.juniqe.com
* rndr-api.juniqe-staging.juniqe.com
* rndr-api.juniqe-integration.juniqe.com

These are the URLs that we redirect to upon a 404 on the **juniqe-shop-images** bucket(s). 